<!--ASLR: Being a postman in the city where they change the street name-->
<!DOCTYPE html>
<html>
    <head>
        <title>First Project</title>
        <link rel="stylesheet" href="Styles.css">
    </head>
    <body style="background-color: rgb(255, 255, 255);">
        <center><h1 style="color:#0004ff;font-family:-apple-system;font-size:50px;text-shadow: 0 0 7px rgb(57, 128, 221)">Memory Corruption Vulnerabilities in 2022</h1></center>
        <hr>
        <center><img src="images/rop3.png" ></center>
        <hr>
        <h4 style="text-align:center;">Hello, I Am Someone Who Learned & Worked Alot in BE, This is Like An Advice, Read This WELL if you're interested, All Informations in this article is based on my skills and experience in BE, So, My Advices Should Be Important To You If You Are Learning it Now, Or Simply Wanna Learn it</h4>
        <center><ttl>Memory Corruption, An Ultra-Simple Introduction</ttl></center>
        <p>Memory Corruption, Also Known As <a href=https://en.wikipedia.org/wiki/Buffer_overflow>Binary Exploitation</a>, is The Process of Providing a Malformed input To A Program in order to change the execution path, Or Simply to Write/Read data to/from the Process's Memory, This Can Compromise The Whole Operating system, By Targeting a High Privilieges Vulnerable Proccess, Fortunately, This Was in the past, <br> in The 1980s, There is No <a href="https://www.techtarget.com/searchsecurity/definition/address-space-layout-randomization-ASLR">ASLR</a> Security, There is No <a href="https://en.wikipedia.org/wiki/Executable_space_protection#Windows">NX/DEP Security</a> Enabled, A Simple Script kid can cause a Denial Of Service, Experts Can Compromise The Whole Computer, Gaining root Privilieges Easily, The Escalation Process is Easy, Once You Have A Shell, You Can  Compromise Any root-process running Localy, Easily, I'm Talking in The 1980s <br><br>
            <img src="images/2.png" alt="Vulnerable Input Function, From User Directly into Static Allocated Memory."><br>
            <p>As An Example, This Photo Shows An insecure Memory Fetch Of User Input (<a href="https://en.wikipedia.org/wiki/Standard_streams">stdin</a> in this context), the <a href="https://www.tutorialspoint.com/c_standard_library/c_function_gets.htm">gets()</a> Function in libc, It Fetches Data From STDIN in a fixed length Memory, Without Any Security Check, So, Attacker Can Easily Control The Program Execution By Overflowing The Buffer With Random Values Or NOP Bytes, Until The First Byte of the <a href="https://stackoverflow.com/questions/2542949/how-is-return-address-specified-in-stack">return address</a>, Now, The Attacker Can Change The Return Address, Triggering The Program To Run An Arbitrary Code.</p>
            <center><res>You're Alright, It is Buffer Overflow, There are many attacks against it, return to stack, return to libc, return to the '.plt', and finally the ROP, Return Oriented Programming.</res></center><br>
            <hr>
            <h4 style="text-align: center;">Okay, We'll Start Talking About Attacks, Exploits, Security Bypass, Evasion, And Finaly Prevention And Protection Against it</h4><br>
            <center><ttl>Buffer OverFlows And The Simplest Exploit Against it</ttl></center>
            <p>Basically, BoF is About Overflowing an Allocated Buffer in The Memory, By Providing A Block Of Data That Doesn't Fit in this buffer, This will cause the Buffer Overflow Problem, Overwriting Other Data in the Process's Memory. <br> The Attacker Will Exploit This Vulnerability in order to manipulate Data in the memory, in order to Bypass some Conditions, (See More About The <a href="https://stackoverflow.com/questions/45898438/understanding-cmp-instruction">cmp</a> Assembly Instruction), Or Simply To Overwrite The Pushed RIP, This Will Cause An Arbitrary Code Execution. </p>
            <center><img src="images/last.jpg" alt=""></center>
            <p>This Picture Shows That We Successfully Overwrited The Pushed RIP Register (Instruction Point Register), Then, When The CPU Reach The End of the code, it will load the pushed RIP From Stack, So A Direct Jump into 0x41414141 is gonna Happen Because we overflowed the buffer with AAAA...., Raising The Segmentation Fault Error By The Kernel, The Segmentation Fault Simply Means That The Program Tried To Access Memory That Shouldn't Be Accessed By This Process (Like Forbidden in The Web Field), Okay, Great, The Hacker Can Directly put A Binary Code That Spawns a shell, connect-back/bind shells..., in the buffer, then overflowing it until the first byte of the Pushed RIP Register, Finally Overwriting it with the address of the first byte of the buffer, that contains the binary code, Okay, This Binary Code That Spawn a shell or do anything malicious to the machine, is named Shellcode, We Now Discussed About the Simplest And Easiest Exploit Against Bufferoverflows, Stack-Based, With Simple Shellcode Injection. Believe This is the most simple one, there are more techniques and bypasses for Bufferoverflows Problems.</p>
           <center> <ttl>The ret2libc Exploit Against Bufferoverflows</ttl></center>
            <p>As The NX/DEP And The Return Address Checker ( __builtin_return_address() Compiler's Function) Security Defenses Comes Out (We'll Discuss Later About NX/DEP, just keep reading), The Kernel Will Always Check if it is gonna do a JMP or CALL To a Non-Executable Memory, if yes then a Segmentation Fault is Raised, The Attack was Detected, logged, Because The Stack Memory is Not Dedicated For Code Execution, And It is marked Non-Executable, so, the simple exploit against BOFs Will Not Work, We need a way that we can inject our code in an executable memory, but our Buffer Is Stored on the Stack?! How ?</p>
           <center> <img src="images/ret2libc.png" alt="ret2libc" height:"700" width="700"></center>
           <p>There is a function Named 'system()' in libc (Basically Libc is the standard C Library, stdio.h stdlib.h....) that's used to execute commands with $SHELL -c, The Surprise is This function takes it's Arguments From The Stack !!!!!! So, No Need to have an Executable-Stack in order to exploit bufferoverflow !!, So How The Return To Libc Attack Works ?, Simple, We Overflow and Overwrite The Pushed RIP, To Jump into The Libc::system(char*) function, Sure, it is placed in an executable Memory !, The Commands we Want To Executes Are Stored On The Stack That We've Overflowed !! Sounds Great !!!, For Evasion techniques We Can Simply Put The Address of the libc::exit(int) After The Libc::system Address, Then, We Did A Successful Exploit, No Detection, No Noise, Everything is Legit, But, Unfortunately, There is a Security Mechanism Against This technique, So, What ?</p>
           <center><ttl>Return-Oriented-Programming Exploit, The Nightmare Of Kernels, The Hardest Exploit Ever</ttl>
           <h4>Warning: If You Are Under 10 Years Old, Please Don't Read This.</h4></center>
           <p>We Are Here, The ROP technique, The Hardest Exploit Ever, The Success rate of ROP is 95.5% With ASLR/NX/DEP/RetValidator/..., Because, Our Shellcode is in the Program's '.text' Section !!, how ?</p>
           <center><img src="images/rop.png" alt=""></center>
           <p>I Think You've Got The Idea, How Hard it is, And The Success Rate, You need To Assemble Your Own Shellcode From The Program's Memory, Putting The Gadget Addresses in a Way to form Your Shellcode Based On Your Goal!, CRAZY !! It is really hard to detect this exploit.</p>
           
           <center><img src="images/rop2.png" alt=""></center>
           <p>No need To Explain, This Photo Contain Everything You Want about the exploit.</p>
           <center><res>ROP is Hard because You Need to be very precise, in Binary exploitation There Are Two Things That Will Happen, 1, The Exploit Gonna Succeed, Then A Denial Of Service Gonna Happen if the attacker is not an expert in shellcode programming, 2, Denial Of Service, You Should Be Very Precise When Exploiting, Like You're Changing The Program's Execution Path, if Your Exploit Doesn't jump back to the program, or create-then-detach a thread with the same Privilieges, or simply to an exit() Syscall You're Gonna Be Detected, Logged...</res>
           <res>Great, We Talked About Stack-Based BufferOverflows with some techniques to exploit it, there are more ways but we talked about 3 only, This is a One Vulnerability in Binary exploitation, there are more like format strings, heap-based overflow, integer overflows,...............................</res></center><hr>
           <center><ttl>Evasion, After A Successful Exploit</ttl></center>
           <p>SO SIMPLE, At the end of your exploit, be sure that the program gonna jump back to the normal execution, or do an exit(int) syscall, or to detach from the process., As An Example:</p>
           <center><img src="images/Screenshot-2019-08-05-at-21.56.11.jpg" alt="" height="500" width="700"></center>
           <center><p>In This Picture, I Injected the execve /bin//sh shellcode into the _start section in the ELF Binary File, Simply, The _start Code Section is the first thing to run when The Kernel Has Successfully Loaded the Binary into Memory, the _start section run before the 'int main(int^NULL, char**^NULL)' function, anyway, when the execution reach the 0x401015, What's Next ?? there is no jump to the __libc_start_main !, This Will Cause the Segfault !, Yes, Logged, Detected!, How Can You Avoid That !!, Simply, exit(int) or return to the normal execution !!, This Type Of Shellcode is very-bad.</p></center>
           <center><pre><code>
            \x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x54\x53\x50\xb0\x3b\xcd\x80
           </code></pre></center>
           <p>Okay, Another Shellcode, Can You Guess if this is a good or bad shellcode ? mmmm think, This Shellcode is bad, Kinda Crazy You'll Say What !!, How Can You Understand Hex Codes ?!! Listen and Focus with me, There is One Byte of 0x80 or the 'int 0x80' for x86 and 'syscall' for x86_64, this means that the shellcode is gonna execute only the execve without an appropriate exit() or jmp-back instruction to evade Logging the Error. simple. <br> <br>You Are Changing the RIP Register, Evasion From Logs And Detection is Hard, if your exploit failed, big problem.</p>
           <center><img src="images/bof.png" alt=""></center>
           <center><h4>We Talked About BufferOverflows, Some of it's Exploitation techniques, Evasion, Now Lets Talk About Prevention, And Protection.</h4></center>
           <center><ttl>Stack-Based Bufferoverflow Preventions</ttl></center>
           <p>To Prevent Bufferoverflows, Every Function You Use Make Sure that it is designed to do a check on the memory size, or simply let you specify the Count of data to write, (Every C/C++ Programmer Now that it's the 'int n' Argument.), why, if you have a 5 Bytes Buffer, You need to write 5 Bytes into it ONLY !, if the function detect that you're trying to write more data, it returns, or simply write the n bytes you passed to it via the 'int n' Arg..</p>
           <center><ul>
               <li>Safe Functions, Don't Use gets, use fgets, Don't use strcpy, use strncpy, Don't use strcat, use strncat......</li>
               <li>Buffer Size, Make Sure You Allocated The Right Size, Don't use strncat(char*dest, char*src, 5) when the char*dest is a 4 bytes in size.</li>
               <li>Do not use the stack for Dynamic Memory Allocation, (example: char str[sizeof(*len)]), Use the heap for Dynamic Memory Allocation.</li>
               <li>Make Sure You strip your Binary Always.</li>
               <li>Fuzzzzz it Well, Fuzz it before you share it.</li>
           </ul></center>
           <center><ttl>Stack-Based Bufferoverflows Protection</ttl></center>
           <p>Protections, ASLR, Being a Postman in the city where they change the street name. <br>DEP/NX, Trying to swim in your car. <br>mmmm, I'm Trying to explain, ASLR, Address space Layout Randomisation, randomly moves around the address space locations of data regions. Typically, buffer overflow attacks need to know the locality of executable code, and randomizing address spaces makes this virtually impossible. <br>NX/DEP, No Execute Bit, Data Execution Prevention, flags certain areas of memory as non-executable or executable, which stops an attack from running code in a non-executable region. <br>SEHOP, Structured exception handler overwrite protection, helps stop malicious code from attacking Structured Exception Handling (SEH), a built-in system for managing hardware and software exceptions. It thus prevents an attacker from being able to make use of the SEH overwrite exploitation technique. At a functional level, an SEH overwrite is achieved using a stack-based buffer overflow to overwrite an exception registration record, stored on a thread’s stack</p>
           <hr>
        <center><ttl>Binary Exploitation Require:</ttl> </center>
        <p>It Requires alot of skills in different fields, Those Are Some Basic Skills That every Binary Exploiter Should Have:</p>
        <ol>
            <li>Binary Reverse Engineering Skills (The Higher Your RE Skills Are, The More Success You'll Achieve  In The exploitation).</li>
            <li>C/C++ Mainly</li>
            <li>High Skills in The Assembly Language (AT&T is Recommended Over Intel Syntax, But, You Should Learn The Both).</li>
            <li>Debugging, Disassembling Skills, Most Of Your Work Is about Debugging, Disassembling The Binary For Analysis And Tests.</li>
            <li>A Strong Knowledge Of Low-Level, Hardware I/O, CPU, Memory I/O, Manual Memory Management, And A Lot...</li>

            <p>Want to Start Doing Binary Exploitation ??, I Recommend You First, To Learn Shellcode Writing, Everyone in the BE should Write Their own exploits/shellcodes, Diving into BE is Hard, Painful.</p>
            <hr>
            <center><ttl>Should Hackers Learn it in 2022 ?</ttl></center>
            <table>
                <tr>
                    <th>Hacker</th>
                    <th>Learn Binary Exploitation</th>
                    <th>Why</th>
                </tr>
                <tr>
                    <td>IoT Hackers</td>
                    <td>Yes</td>
                    <td>IoT Devices Do Not Support Neither ASLR, Nor NX/DEP, Nor SEHOP, .....</td>
                </tr>
                <tr>
                    <td>Web Hackers</td>
                    <td>No</td>
                    <td>It is Dead in the Web Field</td>
                </tr>
                <tr>
                    <td>Local Softwares/Services Pentesters</td>
                    <td>Keep it Knowledge, Do not Put A Big Effort in it</td>
                    <td>ASLR, DEP, There is No PC in 2022 with ASLR DEP Disabled.!.</td>
                </tr>
            </table>
        </ol></p>
        <center>
            <h1 style="color:rgb(255, 0, 0); font-family: 'Impact';text-shadow:0 0 20px rgb(0, 0, 0);">You Should Understand That..., No Body Cares If You Can Do Binary Exploitation </h1>
        </center>
        <blockquote><h3 style="color:rgb(0, 0, 0);font-family:sans-serif;">Yes I Know It's a Hobby, But Can You Get a Job With it? 0x00, So Don't Put Your 24 on it</h3></blockquote>
    </body>
</html>
